#include "tetris.h"

int block[7][4][4][4] = { // [블록종류][회전][세로][가로]

	{	//J미노 (0번 블록)
		0,0,0,0,	//0번 방향
		0,1,0,0,
		0,1,1,1,
		0,0,0,0,

		0,0,0,0,	//1번 방향
		0,0,1,1,
		0,0,1,0,
		0,0,1,0,

		0,0,0,0,	//2번 방향
		0,0,0,0,
		0,1,1,1,
		0,0,0,1,

		0,0,0,0,	//3번 방향
		0,0,1,0,
		0,0,1,0,
		0,1,1,0
	},
	{	//L미노 (1번 블록)
		0,0,0,0,	//0번 방향
		0,0,0,1,
		0,1,1,1,
		0,0,0,0,

		0,0,0,0,	//1번 방향
		0,0,1,0,
		0,0,1,0,
		0,0,1,1,

		0,0,0,0,	//2번 방향
		0,0,0,0,
		0,1,1,1,
		0,1,0,0,

		0,0,0,0,	//3번 방향
		0,1,1,0,
		0,0,1,0,
		0,0,1,0,
	},
	{	//○블록 (2번 블록)
		0,0,0,0,	//1번 방향
		0,1,1,0,
		0,1,1,0,
		0,0,0,0,

		0,0,0,0,	//2번 방향
		0,1,1,0,
		0,1,1,0,
		0,0,0,0,

		0,0,0,0,	//3번 방향
		0,1,1,0,
		0,1,1,0,
		0,0,0,0,
		
		0,0,0,0,	//4번 방향
		0,1,1,0,
		0,1,1,0,
		0,0,0,0,
	},
	{	//T미노 (3번 블록)
		0,0,0,0,	//1번 방향
		0,0,1,0,
		0,1,1,1,
		0,0,0,0,

		0,0,0,0,	//2번 방향
		0,0,1,0,
		0,0,1,1,
		0,0,1,0,

		0,0,0,0,	//3번 방향
		0,0,0,0,
		0,1,1,1,
		0,0,1,0,

		0,0,0,0,	//4번 방향
		0,0,1,0,
		0,1,1,0,
		0,0,1,0,
	},
	{	//I미노 (4번 블록)
		0,0,1,0,	//2번 방향
		0,0,1,0,
		0,0,1,0,
		0,0,1,0,

		0,0,0,0,	//1번 방향
		0,0,0,0,
		1,1,1,1,
		0,0,0,0,

		0,1,0,0,	//4번 방향
		0,1,0,0,
		0,1,0,0,
		0,1,0,0,

		0,0,0,0,	//3번 방향
		1,1,1,1,
		0,0,0,0,
		0,0,0,0,
	},
	{	//Z미노 (5번 블록)
		0,0,0,0,	//1번 방향
		0,1,1,0,
		0,0,1,1,
		0,0,0,0,

		0,0,0,1,	//2번 방향
		0,0,1,1,
		0,0,1,0,
		0,0,0,0,

		0,1,1,0,	//3번 방향
		0,0,1,1,
		0,0,0,0,
		0,0,0,0,

		0,0,1,0,	//4번 방향
		0,1,1,0,
		0,1,0,0,
		0,0,0,0
	},
	{	//S미노 (6번 블록)
		0,0,0,0,	//1번 블록
		0,0,1,1,
		0,1,1,0,
		0,0,0,0,

		0,0,1,0,	//2번 블록
		0,0,1,1,
		0,0,0,1,
		0,0,0,0,

		0,0,1,1,	//3번 블록
		0,1,1,0,
		0,0,0,0,
		0,0,0,0,

		0,1,0,0,	//4번 블록
		0,1,1,0,
		0,0,1,0,
		0,0,0,0
	}
};


void new_block_maker(void) {	//새로운 블록을 생성하는 함수
	block_X = 4;	//화면의 중간에 블록을 출력해야하기에 4를 준다
	block_Y = 0;	//화면의 제일 상단에서부터 내려오게 해야하기 때문에 0
	block_rotation = 0; //회전 방향

	NextBlockPush(); // 다음에 나올 블럭 밀어주기
	PrintNextBlock();//다음블록 넣어주기	block_type 

	for (int y = 0; y < 4; y++){
		for (int x = 0; x < 4; x++) {
			if (block[block_type][block_rotation][y][x] == 1){	
				//블록의 모양은 1로 만들어져있다
				//1의 값을 가진 칸의 모양을 따라 블록을 넣어준다.
				board[block_Y + y][block_X + x] = MBLOCK;
			}
		}
	}
	flag_neednewblock = 0;	//새로운 블록이 매번 필요한것이 아니기때문에 플래그를 꺼준다.
}

void DeletShadowBlock(void) {	//그림자 블록 지워주는 함수
	for (int y = 0; y < board_SIZE_Y - 1; y++){	//보드의 Y축 탐색
		for (int x = 0; x < board_SIZE_X - 1; x++) {	//보드의 X축 탐색
			if (board[y][x] ==  SBLOCK){	//현재 위치에 쉐도우 블록이 있으면
				board[y][x] = EMPTY;		//비워줄 것
			}
		}
	}
}

void MakeShadowBlock(void) {	//그림자 블록 생성 함수
	int shadow_y = 0;
	while (1){
		if (CrushCheak(0, shadow_y + 1 , 0) == TRUE) {
			++shadow_y;	//그림자 블록이 현 위치에서 가장 아래의 픽스된 블록과 충돌할 때 까지 y위치를 내림
		}
		if (CrushCheak(0, shadow_y + 1, 0) == FALSE) {	//충돌확인이 되었을 때
			for (int y = 0; y < 4; y++){
				for (int x = 0; x < 4; x++) {
					if (block[block_type][block_rotation][y][x] == 1 && board[block_Y + y  +shadow_y][block_X + x] < 1){
						board[block_Y + y + shadow_y][block_X + x] = SBLOCK;
						//현재 블록의 모양이 보드의 바닥에 닿으면
						//그 위치에 그림자 블록을 생성
					}
				}
			}
			shadow_y = 0;	//함수가 끝날 때 좌표 초기화
			return;
		}
	}
}

void MBlockDeleter(void) {	//홀드 시 현재 블록을 지워주는 함수
	for (int y = 0; y < board_SIZE_Y - 1; y++) {	//보드의 Y축 탐색
		for (int x = 0; x < board_SIZE_X - 1; x++) {	//보드의 X축 탐색
			if (board[y][x] == MBLOCK) {	//현재 위치에 움직이는 블록이 있으면
				board[y][x] = EMPTY;		//비워줄 것
			}
		}
	}
}